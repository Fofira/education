# Что такое нагрузочное тестирование, тестирование отказоустойчивости и стресс-тестирование? Что их отличает друг от друга?
## Нагрузочное тестирование
Современное программное обеспечение просто обязано бесперебойно работать под колоссальными нагрузками. Любого рода проблемы, связанные с плохой производительностью, могут стать причиной отказа клиентов от использования вашего ПО. В связи с этим, проведение качественного нагрузочного тестирования должно стать обязательным, для обеспечения стабильности работы ваших приложений.  
**Нагрузочное тестирование** (Load Testing) - это автоматизированное тестирование, имитирующее работу определенного количества бизнес пользователей на каком-либо общем (разделяемом ими) ресурсе.  
**Нагрузочное тестирование - сложный процесс:**
1. Это серьезная исследовательская и аналитическая работа
2. Это автоматизированное тестирование, требующее серьезных навыков программирования, а также знания сетевых протоколов и различных серверов приложений и баз данных
3. Существуют разные виды нагрузочного тестирования, ставящие перед собой разные цели

## Тестирование отказоустойчивости
**Тестирование отказоустойчивости** (Fault Tolerance Testing/Failover Testing) — это процесс проверки надежности и стабильности программного обеспечения при возникновении сбоев, ошибок или непредвиденных ситуаций. **Цель** данного вида тестирования — определить способность системы продолжать работу и восстанавливаться после возникновения проблем.  
Сегодня рынок ПО насыщен множеством продуктов, и пользователи ожидают, что их программное обеспечение будет работать без сбоев. Таким образом, важность тестирования на отказоустойчивость связана с повышением качества продукта, удовлетворением потребностей пользователей и укреплением доверия к бренду.  
**Процесс тестирования на отказоустойчивость включает в себя следующие этапы:**
1.	Анализ требований — вначале определяются требования к отказоустойчивости системы.
2.	Проектирование тестов — на этом этапе разрабатываются тестовые сценарии, которые проверяют работу системы в различных условиях.
3.	Подготовка среды тестирования — подготавливается среда, в которой будет проводиться тестирование (включая аппаратное и программное обеспечение).
4.	Выполнение тестов — тесты выполняются согласно разработанным тестовым сценариям.
5.	Анализ результатов — результаты тестов анализируются и документируются. Если обнаружены проблемы, они передаются на доработку разработчикам.

Надежность отказоустойчивой системы характеризуется количеством девяток. Например, любая веб-страница гарантирует стабильную работу в 99% случаев, а база данных организации уровня «Сбербанка» — 99,9999%.
## Стресс-тестирование
**Стресс-тестирование** (Stress Testing) - это исследование изменений свойств системы или объекта в нестандартных (стрессовых) условиях.  
Стресс-тестирование - это отрицательное/негативное тестирование, которое проводят при больших нагрузках или нагрузках, выходящих за допустимые пределы, чтобы определить поведение системы при таких обстоятельствах, точку отказа системы (числовые показатели метрик), показываются ли корректные ошибки при этом и не теряются ли данные. Это тестирование также называют Fatigue testing.  
**Виды стресс-тестирования:**
- **Распределенное стресс-тестирование:** тесты выполняются для всех клиентов с сервера для отслеживания их статуса, а также для выявления сбоев из-за чрезмерного стресса;
- **Стресс-тестирование приложения:** основное внимание в этом тестировании уделяется обнаружению дефектов в программном обеспечении, связанных с блокировкой данных (locking and blocking), проблемами сети и узкими местами производительности;
- **Транзакционное стресс-тестирование:** транзакционное тестирование выполняет стресс-тестирование одной или нескольких транзакций между различными программными продуктами или приложениями. Его основная цель - точная настройка и оптимизация системы для повышения ее производительности;
- **Систематическое стресс-тестирование:** интегрированное стресс-тестирование, систематическое стресс-тестирование, используется для тестирования нескольких систем, работающих на одном сервере. Это позволяет группе тестирования обнаруживать дефекты, когда данные одного программного обеспечения блокируют другое программное обеспечение;
- **Исследовательское стресс-тестирование:** используется для тестирования системы в необычных условиях, которые маловероятны в реальном сценарии. Эти сценарии стресс-тестирования позволяют группе обнаруживать различные необнаруженные проблемы и ошибки в системе;

## Различия
Существуют некоторые существенные различия между тестированием производительности, стресс-тестированием и нагрузочным тестированием, хотя все три вида тестирования имеют решающее значение для обеспечения функциональности и надежности программных приложений.

 Параметры | Нагрузочное тестирование | Тестирование отказоустойчивости | Стресс-тестирование
 -- | -- | -- | --
Суть | Проверка работоспособности при заданной нагрузке | Проверка возможности системы переключения на резервный сервер | Проверка работоспособности при экстремальных нагрузках
Цель | Оценка производительности и масштабируемости системы при заданной нагрузке | Оценка готовности системы к аварийным ситуациям и возможности переключения на резервный сервер в случае сбоя | Оценка границ возможностей системы при экстремальных условиях
Что оценивает | Эффективность приложения при реалистичных нагрузках | Способность приложения задействовать механизмы, предотвращающие нарушение работоспособности, производительности и повреждения данных | Производительность приложения в сложных условиях
В каких случаях проводится | Как часть обычного процесса тестирования | Как одноразовое мероприятие для имитации экстремальных условий. Особенно актуальна для систем, работающих бесперебойно | Как одноразовое мероприятие для имитации экстремальных условий. Часто проводится, если заказчик предвидит резкое увеличение нагрузки на систему.
Область тестирования | Поведение системы в пределах значений нагрузки | Поведение системы в случаях сбоя серверов или при других неблагоприятных факторах | Поведение системы за пределами значений нагрузки
Что проверяют | Время отклика системы и скорость обработки запросов от пользователей, сколько ресурсов “съедает” система – сетевых, процессорных, памяти | Количество запросов в секунду, транзакций в секунду, время отклика от сервера, процент ошибок в ответах, утилизация аппаратных ресурсов и т.д. (метрики производительности) | Частота ошибок, критическая точка и максимальный пользовательский трафик, показываются ли корректные ошибки при этом и не теряются ли данные
Способ проведения | Увеличение нагрузки до пикового значения, при котором система начнет тормозит | Сценарии сбоев с измерением времени, за которое система восстанавливает работу. Собранные метрики проходят проверку на соответствие заданным требованиям. | Постоянная перегрузка ресурса до тех пор, пока сервер полностью «не ляжет»
Продолжительность | Нагрузка на систему подается на протяжении 4-8 часов | Продолжительность нагрузки может варьироваться в зависимости от целей и возможностей проекта, доходя до семи дней и более. | Зависит от области применения. В среднем от 15 мин до 2 часов. Чем дольше проводится, тем больше известно, насколько стабильна система.
На какие вопросы отвечает | Соответствует ли нефункциональным требованиям система? | Сможет ли система сама переместиться на другой сервер, если откажет основной? | Что случится при незапланированной нагрузке?
Позволяет узнать | Сможет ли система обрабатывать запросы в заданное время при заданной нагрузке | Сможет ли система продолжать работу без перерывов в случае сбоя | Какая максимальная нагрузка может быть обработана системой
Итог тестирования | Выясняется, соответствует ли система требованиям производительности. Локализация узких мест в производительности приложения и дефектов, подробное профилирование всех компонентов системы и утилизация аппаратных ресурсов под целевой нагрузкой | Выясняется, как изменится производительность системы в течение длительного периода времени под нагрузкой, например, в течение недели. Снизится ли уровень производительности? Способно ли приложение выдерживать стабильную нагрузку без критических сбоев? | Фиксируется количество пользователей, которое приложение выдерживало, соответствуя требованиям производительности, и сколько выдержать не смогло. Первое значение будет пределом производительности приложения.
Инструменты | BlazeMeter, JMeter, LoadRunner, Apache JMeter, NeoLoad, The Grinder, WebLOAD RadViews, Gatling, CloudTest by Soasta и др. | Load Impact, AWS Resilience Hub | BlazeMeter, JMeter, LoadRunner и Apache JMeter

# Приведите по одному примеру выполнения каждого из трёх видов тестирования (в контексте проверки базы данных большого веб-приложения).
## Пример нагрузочного тестирования
Имеется крупный интернет-магазин верхней одежды и аксессуаров со следующей проблемой.  
Для "магазина" разработчик собрал новый сайт. Чтобы проверить, какую нагрузку он выдерживает, направили часть трафика со старого сайта на новый. Сайт «лег». Перед клиентом встал вопрос — «чинить» новый сайт или «хоронить», и разработать ещё один на фреймворке.  
Пробуем провести нагрузочное тестирование интернет-магазина.
### 1. Постановка целей и задач
Проверяем максимальную производительность интернет-магазина — чтобы "магазин" понял, что можно получить на текущем оборудовании, и увидеть перспективы масштабирования проекта.  
**Цель теста:** выяснить предельное количество хитов в секунду, которое может выдержать текущая конфигурация «сервер плюс сайт» и определить самые «тяжелые» страницы для последующей оптимизации.  
### 2. Определение условий и инструментов нагрузочного тестирования
Для прогрева кеша использовали статичную нагрузку. В качестве инструмента нагрузочного тестирования — Яндекс Танк с модулем Phantom. Phantom отличается высокой производительностью, но не позволяет генерировать POST-запросы — нельзя проверить сценарии отправки отзывов, авторизации на сайте и добавления товаров в корзину. Поэтому оцениваем количество запросов в секунду, которое может выдержать сайт, без анализа добавления товаров в корзину.  
**Конфигурация Web сервера:**
- Intel(R) Xeon(R) CPU E5-1650 v3 @ 3.50GHz
- RAM: 64 Gb
- SSD: 500 Gb (RAID 1)

**Конфигурация сервера БД:**
- Intel(R) Xeon(R) Silver 4214 CPU @ 2.20GHz
- RAM 188 Gb
- SSD NVME 1Тб (RAID 1)

Серверы работали на OS Debian 9.11
### 3. Подготовка к нагрузочному тестированию
Важно грамотно определить сценарии нагрузочного тестирования. Не всегда понятно, на что более всего тратятся серверные ресурсы — куда направлять ботов. Направив нагрузку не на проблемные места сайта, можно получить хорошие, но ложные результаты. Поэтому нужно как можно точнее смоделировать действия пользователей.  
Чтобы определить сценарии, выгружаем список страниц сайта и формируем перечень из примерно 1000 страниц с примерным соотношением:
- 70% — страницы товаров;
- 20% — страницы категорий товаров;
- 5% — URL, содержащие фильтры;
- 5% — прочие страницы (главная, страницы блога, информационные страницы).

### 4. Определение предела теста
Выставляем лимиты, при достижении любого из которых тест автоматически останавливается:
- time(3s,20s) — если среднее время ответа более 3 секунд в течение 20 секунд;
- http(5xx,100%,10s) — если в течение 10 секунд 100% обращений выдают 5xx ошибки;
- net(xx,100%,5s) — если в течение 5 секунд 100% получаем ошибки сети, такие как 104 — Connection reset by peer и 110 — Connection timed out.

### 5. Запуск и анализ результатов нагрузочного тестирования
Чтобы получить корректные значения, тест сайта нужно выполнять в несколько этапов.  
**Этапы тестирования:**
- Подготовка конфигурации Яндекс Танк.
- Пробный "обстрел" для проверки конфигурации, примерных лимитов и шагов наращивания интенсивности, выявление ошибок конфигурации тестового задания.
- Непосредственно тестирование — его лучше выполнить несколько раз.

#### 1) Проведение тестов и анализ результатов нагрузочного тестирования
Проводим несколько тестов и получаем результаты.  
**RPS (request per second)** — число запросов в секунду на страницы сайта, которые производили при нагрузочном тестировании. Показывает примерное количество запросов, после которого был прерван тест — либо из-за отсутствия ответа по сети, либо из-за ошибок в HTTP запросах.
##### Тест 1
**Условия:** запущен тест примерно на 1000 страниц, отсортированных по типам и по алфавиту. Кэш на сайте не сбрасывали.  
**Результат:** RPS=256. Сайт выдержал нагрузку, и нагрузка на сервер составила не более 30%. Нагрузка на базу данных была мизерной. LoadAverage не превышал трех. Тест прервался по причине сетевой недоступности из-за повышенной нагрузки на канал связи.
##### Тест 2
**Условия:** был сброшен кэш. Тест запущен по большому списку отсортированных страниц.  
**Результат:**RPS=11. При достижении примерно 11 запросов в секунду нагрузка на базу данных выросла до 100%.
##### Тест 3
**Условия:** тестирование сайта по прежнему списку при «прогретом» кэше.  
**Результат:** RPS=250. При тестировании сервер был загружен максимум на 30%. База данных тоже была загружена не более чем на 30%, а зачастую меньше. Тест прервался по причине сетевой недоступности из-за повышенной нагрузки на канал связи. На внешнем сетевом интерфейсе web-сервера сайта загрузка канала превысила 800 мегабит в секунду.
##### Тест 4
**Условия:** тестирование демо-сайта на чистом Битриксе при пустом кэше с базой на локальном сервере.  
**Результат:** RPS=168. Нагрузка на процессор выросла до 100%.
##### Тест 5
**Условия:** Тестирование демо сайта с шаблоном готового решения Aspro Next, на котором базировался код тестируемого сайта при пустом кэше с базой на локальном сервере.  
**Результат:** RPS=128. Нагрузка на процессор выросла до 100%.
#### 2) Выводы по результатам нагрузочного тестирования
- С «прогретым» кэшем на текущих серверах сайт способен выдерживать существенные нагрузки — более 300 RPS.  
- Без оптимизации запросов к БД на товарных страницах и страницах каталога со сброшенным кэшем сайт не способен выдержать даже малую нагрузку. Это создает риск падения сайта в случае очистки кэша.  
- Специально были проанализированы эталонные демо-сайты чистого Битрикса и сайта на готовом решении Aspro. На тестируемом оборудовании без кэша эталонные демо-сайты показали существенную производительность, что дало основание изучать код сайта на предмет его оптимизации, а также оптимизации запросов к БД.  
- Ресурсы серверов (особенно сервера БД) имеют большой запас по мощности и после проведения рекомендуемых оптимизаций могут быть сильно избыточными.

### 6. Итог
Следом за нагрузочным тестированием проведен глубокий технический аудит сайта. Сделан рефакторинг компонентов и исправлены все выявленные в результате аудита проблемы. Теперь сайт выдерживает до 60 тысяч посетителей в сутки.
## Пример Стресс-тестирования
Имеем банковское приложение, которое ожидает большого объема сделок в конце финансового года. Владелец приложения хочет убедиться в отсутствии проблем с производительностью при работе с ожидаемой нагрузкой. Чтобы оценить поведение приложения при высоких требованиях, будет проведено стресс-тестирование. Поведение приложения при большой нагрузке данных будет оцениваться с помощью объемного тестирования и тестирования всплесков, которые имитируют внезапные всплески пользовательского трафика. Постепенно увеличиваем нагрузку. Если все прошло без проблем, нагрузка снова увеличивается.  
Владелец приложения сможет оптимизировать производительность приложения и убедиться, что оно может управлять ожидаемой нагрузкой с помощью результатов стресс-тестирования.  
## Пример тестирования на отказоустойчивость
Этот вид тестов важен для организаций, которые работают круглосуточно и ежедневно, иначе компаниям грозит потеря клиентов и денег.  
Имеется интернет-магазин, нужно проверить его отказоустойчивость.  
Процесс тестирования на отказоустойчивость включает в себя следующие этапы.

### 1. Анализ требований
Вначале определяются требования к отказоустойчивости системы.  
Методика  подобного  тестирования  заключается в симулировании различных условий сбоя и последующем изучении и оценке реакции защитных систем.  
Предположим, уборщица в серверной мыла пол и выдернула штекер из розетки – у сервера пропало питание. Сможет ли система быстро развернуться заново на новом сервере или в облаке?  
**Объектом тестирования являются весьма вероятные эксплуатационные проблемы:**
- Отказ электричества на компьютере-сервере
- Отказ электричества на компьютере-клиенте
- Незавершенные циклы обработки данных (прерывание работы фильтров данных, прерывание синхронизации).
- Объявление или внесение в массивы данных невозможных или ошибочных элементов.
- Отказ носителей данных.

### 2.Проектирование тестов
На этом этапе разрабатываются тестовые сценарии, которые проверяют работу системы в различных условиях.  
Разработка тестовых сценариев должна производиться с учетом всех особенностей тестируемой системы.  
**Возможные тестовые сценарии могут включать:**
-	проверка работы приложения при падении сервера
-	проверка работы приложения при отсутствии интернет-соединения
-	проверка работы приложения при некорректном вводе данных пользователем

Например, можно создать тестовый сценарий, в котором сервер будет выключаться в процессе оформления заказа. В результате, можно увидеть, как система реагирует на подобную ситуацию, и определить, насколько успешно она восстанавливается после возникновения сбоя.  
**Факторы, влияющие на надежность программного обеспечения, делят на следующие 2 группы:**
1. ***Внутренние:***
  - ошибки проектирования при постановке задач
  - ошибки алгоритмизации задач
  - ошибки программирования
  - недостаточное качество средств защиты
2. ***Внешние:***
  - ошибки персонала при эксплуатации
  - искажения информации в каналах связи
  - сбои и отказы аппаратуры ЭВМ

**Для того, чтобы обеспечить тестовое покрытие обоих типа факторов, можно разделить тесты на проверку отказоустойчивости на 3 основных типа:**
1. ***Тестирование программной составляющей***. Можно выделить два основных подтипа тестирования в зависимости от механизмов резервирования:
  - в случае, когда есть необходимость человеческих действий для преодоления последствий сбоев (в основном встречается в отсутствии резервирования)
  - в случае, когда механизмы отказоустойчивости автоматически переключают систему с поврежденной программной компоненты на ее замену.
2. ***Тестирование аппаратной составляющей***. В зависимости от наличия механизмов отказоустойчивости в определенных аппаратных компонентах системы, можно проводить тестирование тех или иных компонент. Наиболее часто встречающиеся:
  - сервера
  - составляющие серверов
  - сервера баз данных
  - сетевая инфраструктура
  - системы централизованного хранения данных (например, SAN – Storage Area Network)  
  При тестировании аппаратной составляющей можно так же частично покрыть тестирование расположенной на ней программной составляющей. Так, например, отключение сервера повлечет за собой выход из строя расположенных на нем процессов.
3. ***Тестирование значительного сбоя***. При наличии полной копии системы в отдельном дата центре проводится тестирование значительно сбоя – эмуляция глобального выхода из строя системы в основном дата центре и, как результат, перевод пользователей на запасной дата центр системы.  
Тестирование значительного сбоя, или переход на запасной дата центр, в большинстве случаев является комплексной операцией, включающей в себя множество операций на инфраструктурном уровне, системном уровне и на уровне приложения.

При тестировании отказоустойчивости, должны быть определенные параметры и критерии (совокупно - **метрики**) по которым можно судить об успешности проведенного теста.  
**Согласно общепринятому подходу, при анализе надежности ПО используются традиционные для технических систем критерии надежности:**
- Вероятность безотказной работы.
- Вероятность отказа.
- Интенсивность отказов.
- Средняя наработка на отказ.
- Среднее время восстановления.
- Коэффициент готовности.

### 3. Подготовка среды тестирования
Подготавливается среда, в которой будет проводиться тестирование (включая аппаратное и программное обеспечение).  
Например, в облаке устанавливается виртуальная машина, которая подходит по указанным требованиям. Устанавливают операционную систему и подготавливают среду для проведения нагрузки.  
### 4. Выполнение тестов
Тесты выполняются согласно разработанным тестовым сценариям.  
Производительность системы проверяется под нагрузкой в течение длительного периода времени. Примером является обычный нагрузочный тест, длительностью 8 часов + пиковые нагрузки, выше или равные стресс-тестированию. Проверяется, как сайт поведет себя при кратковременном увеличении нагрузки.  
Тестировщики проверяют, как будет вести себя система, если произойдет какой-нибудь сбой.  
**Чтобы тестирование дало результаты, разработчики делают следующие шаги:**
1. ***Проверяют готовность объекта тестирования***
Тестирование начинается после проверки готовности. Работоспособность компонентов платформы идентифицируется мониторингом изменения значений на тестовых элементах. Выполненные действия подтверждают готовность объекта к тестированию.
2. ***Запускают приложение***:
  - ***Когда оборудование работает отлично***
  - ***В случае отказа одного из серверов***.
    - *Симулируют внезапный отказ электричества на компьютере (обесточить компьютер).*
    В ходе тестирования моделируется временный сбой смежной системы с продолжительностью, определяемой временем восстановления смежной системы (например: время перезагрузки, требуемое время восстановления). Запускают клиента, который нагружает систему по заданным параметрам. При тестировании собирают логи, которые еще не отредактированы. Уже в это время намечается определенная динамика работы приложения.
    Этап тестирования предполагает имитацию внезапного отказа (отключение питания) одного из серверов, с диагностикой общей доступности тестируемого объекта посредством постоянного отклика на команду ping.  
    Запускается команда ping для проверки общей доступности кластера и виртуальных машин.  
    Средствами модуля удаленного управления (RMM) в меню управления питанием (Remote Control-Server Power Control) выбирается пункт Power OFF Server и выполняется отключение питания.  
    В веб-консоли управления появляется предупреждение о выходе из строя узла и потере связи между узлами и получено автоматическое оповещение на e-mail о статусе узлов.  
    - *Симулируют потерю связи с сетью (выключить сетевой кабель, обесточить сетевое устройство)*
    - *Симулируют отказ носителей (обесточить носитель данных)*
      - Отказ A/O путей при случайной нагрузке маленькими блоками 4k и переключение на A/N путь.  
        100%_read_4k_random  
        100%_write_4k_random  
      - Отказ A/O путей при последовательной нагрузке большими блоками 128k и переключение на A/N путь.  
        100%_read_128k_seq  
        100%_write_128k_seq  

      Со стороны СХД при переключениях оптимальных путей на неоптимальные будет задействован NTB интерфейс.  
      **Шаги тестирования по каждому шаблону:**
      1. Созданы две группы DDP по 12 дисков SAS SSD.
      2. Созданы 4 логических тома на каждой группу по 500 ГБ и презентованы хосту
      3. Далее запускается каждый файл с параметрами нагрузки FIO, длительность теста 30 минут.
      4. После 10-минутного запуска нагрузки на контроллере Engine-0 отключаются одновременно 2 FC таргета, что позволит смоделировать отказ A/O путей.
      5. В течение 5-ти минут наблюдаем за параметрами iops, mb/sec, latency во время нагрузки, фиксируем результат.
      6. С 15-ой минуты восстанавливаем отключенные FC таргеты на контроллере Engine-0 и выполняем аналогичное отключение таргетов для соседней дисковой группы DDP, находящейся на контроллере Engine-1.
      7. После 20-ой минуты восстанавливаем отключенные FC таргеты, завершаем тестирование, фиксируем результаты.

    - *Симулируют ситуацию наличия в системе неверных данных (специальный тестовый набор или база данных).*
    - *Симулируют сценарии отказа путей СХД*

3. ***Смотрят, как следующий сервер, который рабочий, перехватывает информацию и начинает работать вместо отказавшего***.
  - *При симулировании внезапного отказа электричества на компьютере*
    Наблюдаем, что виртуальные машины переходят в статус running/WARNING и по-прежнему непрерывно функционируют.  
  - *При симулировании отказа носителей*
    Средняя загрузка процессора составила 40-45%, средняя утилизация памяти - 30%. После 4-ого шага тестирования, а именно отказа оптимальных путей и переключения нагрузки через NTB интерфейс, есть просадка в скорости, задержки также возрастают, но остаются на приемлемом уровне для таких условий. Дисковая группа не пытается переключиться на соседний контроллер при потере FC соединения и находится на том же самом контроллере. Аналогичный тест для второй группы соседнего контроллера показал идентичные результаты.  
    При последовательном характере нагрузки с блоком 128k видим более высокую утилизацию NTB интерфейса при отказе FC путей. В обоих вариантах тестов нагрузка упирается практически в максимальную пропускную способность – в нашей конфигурации это 2x16Gb. Как и в предыдущих тестах при отключении FC таргетов группа остается на том же контроллере, где и была.
4. ***Проверяют, без ошибок ли проходит перехват информации***. Смотрят, как проходит отправка информации на другой канал.
  - *При симулировании внезапного отказа электричества на компьютере*  
    **Полученные результаты свидетельствуют о:**
    - бесперебойном взаимодействии и наличии непрерывной связи между компонентами платформы;
    - возможности вносить изменения средствами администрирования компонентов платформы.

    Результаты тестирования подтверждают высокий уровень работоспособности и отказоустойчивости платформы, что удовлетворяет ключевому требованию  по обеспечению непрерывности поступления необходимой информации.
  - *При симулировании отказа носителей*
    Вся нагрузка на логические тома идет по неоптимальным путям через интерфейс NTB при некритичнм снижении производительности.

**Замеряются показатели надёжности в тестировании отказоустойчивости сложных информационных систем:**
1. ***Время предотвращение сбоя*** – суммарное время всех действий, необходимых для переключения компоненты на замену (или переключение всей системы на запасной дата центр).
2. ***Время возвращения в нормальное состояние*** – суммарное время всех действий, необходимых для переключения с резервной копии компоненты на основную компоненту (или переключение всей системы с запасного дата центра на основной).
3. ***Потери данных*** – наличие и количество потерянных данных во время сбоя.
4. ***Функциональные ошибки*** – наличие ошибок в функционировании системы во время обработки сбоя.
5. ***Утилизация аппаратных ресурсов*** – уровень использования аппаратных ресурсов во время преодоления сбоев.
6. ***Влияние на метрики производительности*** – для систем с особыми требованиями к производительности, необходимо так же проверять влияние сбоя на производительность системы. Иными словами, стоит совмещать тестирование отказоустойчивости и производительности и обратить внимание на метрики производительности во время предотвращения сбоя.

**Факторы, которые надо учесть при проведении тестирования отказоустойчивости:**
1. ***Тестирование одного одновременного сбоя*** – вероятность возникновения сбоев сразу в двух различных компонентах системы одновременно очень мала и, как следствие, для сокращения трудозатрат на тестирование стоит производить тестирование сбоя только в одном компоненте единовременно. Другими словами, при тестировании отказоустойчивости следует полностью восстановить систему от эмуляции текущего сбоя, прежде чем переходить к тестированию следующей компоненты.
2. ***Проверка отказоустойчивости программной составляющей перед тестированием аппаратной составляющей*** – перед тем, как приступать к тестированию отказоустойчивости аппаратной составляющей, необходимо провести тестирование отказоустойчивости программной составляющей, расположенной на ней. Это необходимо для того, что бы при возникновении ошибок во время тестирования аппаратной составляющей можно было быть уверенным, что эти ошибки возникают не из-за некорректности механизмов отказоустойчивости аппаратной составляющей.
3. ***Необходимость понимания архитектуры системы для успешного создания
сценариев тестирования отказоустойчивости*** – для успешного создания сценариев тестирования отказоустойчивости тестировщикам необходимо глубоко понимать архитектуру системы.
4. ***Необходимость вовлечения системных администраторов*** – так как, зачастую, тестировщики не обладают необходимыми правами доступа для эмуляции выхода из строя компонент, возникает необходимость вовлекать системных администраторов в тестирование отказоустойчивости для выполнения действий по эмуляции сбоев.
5. ***Необходимость функционирования компоненты во время проведения тестов на ее отказоустойчивость*** – необходимо создать такую ситуацию, что бы компонента функционировала (обрабатывала данные) во время эмуляции ее сбоя. Это необходимо для того, что бы реалистично провести тестирование, в особенности относительно проверок на потери данных.

Тест завершается после стабилизации системы в штатном режиме работы или по истечении определнного времени.  
**По завершении процедур восстановления, должно быть достигнуто определенное требуемое состояние данных продукта:**
- Потеря или порча данных в допустимых пределах.
- Отчет или система отчетов с указанием процессов или транзакций, которые не были завершены в результате сбоя.

### 5. Анализ результатов
Результаты тестов анализируются и документируются. Если обнаружены проблемы, они передаются на доработку разработчикам.  
В процессе подобных проверок выясняется, была ли достигнута требуемая степень восстановления системы после возникновения сбоя.  
**Критиериями успешного прохождения системой теста являются:**
-	Система сохранила доступность, в функционале не связанном с функциями смежной системы.
-	Система восстановилась в течение требуемого времени восстановления доступности.

При достижении соответствующих условий сбоя и по результатам работы систем восстановления, можно оценить продукт с точки зрения тестирования на отказ.
# С помощью каких инструментов можно провести нагрузочное тестирование базы данных?
## Apache JMeter
Apache JMeter — самый популярный инструмент с открытым исходным кодом в области тестирования производительности.  
Это Java-приложение, созданное специально для нагрузочного тестирования с возможностью измерения производительности приложений и времени отклика.  
Apache JMeter был создан как open-source альтернатива LoadRunner, поэтому имеет множество сложных функций. Этот толстый клиент в значительной степени управляется кликами правой кнопкой мыши. Это необычно, но дает много возможностей. Кроме того, в Apache JMeter доступны все функции, которые нужны для профессионального нагрузочного тестирования.  
**Особенности:**
-	Возможность тестирования производительности множества технологий с использованием ряда протоколов, таких как HTTP/HTTPS, SOAP и Rest Services, FTP, базы данных с JDBC.
-	Хорошая IDE, которую вы можете использовать для написания и отладки тестов производительности.
-	Начиная с JMeter 3.1 языком программирования по умолчанию стал Groovy.
-	Есть настройки для тестирования производительности мобильных приложений.

Несмотря на популярность этого инструмента, у него есть и некоторые **недостатки**.  
Например, JMeter может быть сложно масштабировать для большого распределенного тестирования. Это особенно верно, если вам нужно использовать несколько машин, поскольку вам придется настроить их для взаимодействия друг с другом.
## Taurus
С технической точки зрения Taurus не является инструментом нагрузочного тестирования. Он скорее работает как обертка над другими решениями, скрывающая сложность performance-тестов.  
Сила Taurus в том, что он позволяет писать тесты на YAML.  
Полноценный сценарий можно описать примерно в десяти строках текста, а это дает командам возможность описывать свои тесты в файлах YAML или JSON. Таким образом вы получите удобочитаемые описания тестов в простых текстовых файлах.  
Это большой шаг вперед по сравнению с прежними временами, когда для написания сценариев для измерения времени загрузки приходилось создавать большие и специфические инструменты.  
**Особенности:**
-	Использование YAML позволит большему количеству членов команды участвовать в тестировании производительности. Кроме того, тест-кейсы будут куда читабельнее, что упрощает код-ревью.
-	Taurus гораздо эффективнее вписывает тестирование производительности в конвейер CI/CD.
-	Taurus предоставляет своего рода слой абстракции поверх JMeter, так же, как и некоторые другие инструменты (например, Locust, Gatling, Grinder и Selenium).
## Locust
Locust — это простой в использовании распределенный инструмент нагрузочного тестирования. Он может помочь вам определить время отклика и выяснить, сколько пользователей способна обрабатывать система одновременно. В качестве языка сценариев используется Python.  
Такие инструменты, как JMeter, основаны на ресурсоемкой потоковой архитектуре. Locust использует событийно-ориентированный подход, потребляющий меньше ресурсов.  
Locust использует такую вещь, как «swarm» (англ. locust — «саранча», а swarm — «рой»). То есть направляется рой саранчи, чтобы создать нагрузку на сайт.  
Для каждого из экземпляров Locust можно отдельно определить желаемое поведение. Это также дает возможность отслеживать процесс роения в режиме реального времени (в веб-интерфейсе).  
**Особенности:**
-	Возможность создавать свои тестовые сценарии с использованием Python.
-	Можно легко масштабировать количество пользователей, которых нужно эмулировать.
-	Приятный веб-интерфейс.
-	Расширяемость.
-	Подходит для тестирования API.

Есть и **минус**: поскольку это более новый инструмент, у него гораздо меньше плагинов, чем у JMeter.
## Fiddler с BlackWidow и Watcher
В списке инструментов для нагрузочного тестирования эта связка может показаться странной. Тем не менее, ее можно успешно использовать для быстрого запуска автоматизированного тестирования производительности.  
С помощью **Fiddler** можно делать много всего, но, вероятно, лучше всего описать его как инструмент захвата трафика.  
Хотя Fiddler сам по себе нельзя рассматривать как решение для нагрузочного тестирования, у него есть много функций, позволяющих отлаживать проблемы с сайтом, а с одним из его многочисленных расширений вы можете добиться еще большего.  
**С помощью Fiddler можно:**
-	устранять проблемы в веб-приложении
-	тестировать безопасность
-	оценивать производительность
-	дебажить веб-трафик с большинства компьютеров и устройств
-	находить узкие места в производительности.

Fiddler уже стал довольно популярным инструментом среди разработчиков. Многие используют его для отладки, чтобы просмотреть HTTP-запросы, которые их компьютер отправляет сервису или сайту.  
**Watcher** — это надстройка безопасности для Fiddler. Этот инструмент выявляет проблемы безопасности в веб-приложении.  
**BlackWidow** — это веб-краулер. Можно указать ему веб-адрес и получить подробную информацию по этому адресу.
## nGrinder
На странице nGrinder на GitHub он описывается как решение для инженерии производительности корпоративного уровня. Он был создан для упрощения стресс-тестирования и как платформа, позволяющая создавать, выполнять и отслеживать тесты.  
**Особенности:**
-	Тесты можно писать на Jython или Groovy.
-	Нагрузку на JVM можно создавать с помощью нескольких агентов.
-	Есть возможность расширения тестов за счет клиентских библиотек, например, jar и py.
-	Можно отслеживать состояние генерации нагрузки агентов производительности.
-	После тестирования результаты из распределенных агентов собираются автоматически.

## The Grinder
The Grinder — это фреймворк на основе Java. Он предоставляет простые в использовании решения для распределенного тестирования с использованием множества машин-генераторов нагрузки для определения времени отклика конечных пользователей. Не придется беспокоиться о каких-либо ограничениях виртуальных пользователей.  
**Особенности:**
-	Можно выполнить нагрузочное тестирование в любой системе, имеющей Java API.
-	Инструмент имеет хороший графический интерфейс.
-	Автоматически управляет клиентскими подключениями и файлами cookie.

## Gatling
Gatling — это инструмент нагрузочного тестирования, написанный на Scala и построенный на базе Akka и Netty.  
Этот инструмент позволяет тестировать и измерять сквозную производительность приложения и легко масштабировать виртуальных пользователей.  
**Особенности:**
-	Простой, но мощный DSL
-	Легкая расширяемость
-	Если известны Scala и его преимущества, этот инструмент нагрузочного тестирования подходит
-	Имеется запись скриптов
-	Инструмент позволяет применять shift-left  подход к тестированию производительности.

## k6
k6 — это ориентированный на разработчиков инструмент нагрузочного тестирования для внутренней инфраструктуры. Его также можно использовать для включения тестирования производительности в CI/CD-пайплайны.  
Этот инструмент создан с использованием Go и JavaScript, поэтому хорошо интегрируется в рабочий процесс большинства разработчиков.  
**Особенности:**
-	Обеспечивает распределенное и облачное исполнение.
-	Возможность оркестровки REST API.

## Tsung
Tsung — это распределенная система нагрузочного тестирования, написанная на Erlang.  
**Особенности:**
-	Высокая производительность. Tsung может симулировать огромное число пользователей (тысячи на одном CPU).
-	Нагрузка может быть распределена на кластер клиентских машин.
-	Динамические сценарии. Можно получать динамические данные с сервера под нагрузкой (без написания какого-либо кода) и использовать их в последующих запросах.
-	Поддерживаются протоколы HTTP, XMPP, LDAP и т.д.
-	В ходе одного замера можно симулировать разные типы пользователей, определив в сценарии их пропорциональное количество.

## Siege
Siege — это утилита командной строки для нагрузочного тестирования HTTP и тестирования производительности. Она призвана помочь разработчикам в оценке производительности их кода в условиях стрессовой нагрузки.  
**Особенности:**  
-	Поддерживает базовую аутентификацию, файлы cookie, протоколы HTTP, HTTPS и FTP.
-	Позволяет своим пользователям подключаться к серверу с настраиваемым количеством симулированных клиентов. Эти клиенты берут сервер в «осаду» (англ. siege — осада).
-	Отлично подходит для простого брут-форс тестирования.

## Bees with Machine Guns
Название Bees with Machine Guns переводится как «пчелы с пулеметами». Это разработка Chicago Tribune.  
Bees with Machine Guns описывается как утилита для вооружения (создания) множества пчел (микроэкземпляры Amazon EC2) для атаки (нагрузочный тест) целей (веб-приложений).  
Этот инструмент может помочь провести нагрузочное тестирование сайта, который должен обрабатывать высокий трафик.  
Когда делаются замеры производительности на машине, все запросы к приложению поступают с одного IP-адреса. Это неэффективно для тестирования балансировки нагрузки. Bees with Machine Guns позволяет ввести пару команд и симулировать трафик, приходящий из нескольких разных источников.  
## Fortio
Fortio — это классная библиотека для нагрузочного тестирования, инструмент командной строки, расширенный эхо-сервер и веб-интерфейс. Написан на языке Go.  
Этот инструмент позволяет задать посекундную нагрузку и записывать гистограммы задержки и другую полезную статистику.  
**Особенности:**
-	Быстрый.
-	Компактный (Docker-образ 3 МБ, минимальные зависимости).
-	Пригоден для многоразового использования.
-	Развитый и надежный инструмент (нет известных мажорных багов; а вот если хочется принять участие в разработке, возможностей для улучшения — масса)

## Puppeteer
Во фронтенде современных приложений интенсивно используется JavaScript. Это повышает необходимость в тестировании производительности фронтенда.  
Для сбора статистики веб-производительности (например, для отслеживания загрузки страницы), получения трассировки DevTools со снимками экрана, получения показателей производительности во время выполнения можно использовать Puppeteer.  
Puppeteer — это библиотека Node, предлагающая высокоуровневый API для управления браузером Chrome или Chromium без пользовательского интерфейса, поверх протокола DevTools.  
В репозитории Puppeteer WebPerf имеются рецепты для автоматизации замеров веб-производительности с помощью Puppeteer.  
## Flood Element
Позволяет проверить нагрузку используя реальный браузер. Flood Element — масштабируемый  инструмент нагрузочного тестирования с использованием реальных браузеров. Такой подход позволяет более точно имитировать то, как реальные пользователи взаимодействуют с приложением.  
Flood Element генерирует нагрузку путем запуска тысяч экземпляров Chromium, Firefox или Webkit.  
В ходе тестирования можно делать все так же, как делают реальные пользователи, открывая браузер и взаимодействуя с элементами страницы. Это может помочь найти проблемы, с которыми сталкивается пользователь.
Flood Element создан на основе библиотеки автоматизации Playwright, благодаря чему отличается высокой скоростью и кроссбраузерной поддержкой.  
Сценарии создаются с использованием TypeScript.
## Artillery
Artillery — это open-source приложение с премиум-сервисами, позволяющими создавать нагрузочные тесты для имитации нагрузки от тысяч пользователей.  
**С помощью Artillery можно получить подробные отчеты о разных показателях производительности:**
-	задержках
-	запросах в секунду
-	конкурентности
-	среднем времени отклика
-	пропускной способности.

Инструмент позволяет прописывать пользовательскую логику и сценарии предварительного тестирования с использованием JavaScript, который имеет широкий спектр доступных NPM-модулей.  
Artillery поддерживает несколько протоколов, включая HTTP, Web Socket, Socket.IO, Kinesis и HLS.
# Какие существуют способы оптимизации (улучшения производительности) базы данных?
## Оптимизация запросов
В большинстве случаев проблемы с производительностью вызваны низкой производительностью SQL-запросов. При попытке оптимизировать эти запросы сталкиваются со многими дилеммами, например, использовать ли IN или EXISTS, писать ли подзапрос или объединение. Можно ускорить запросы SQL с помощью оптимизаторов запросов, которые ускорят запрос и объяснят рекомендации, чтобы учиться на будущее.
## Создать оптимальные индексы
При правильной индексации можно оптимизировать продолжительность выполнения запроса и повысить общую производительность базы данных. Индексы достигают этого, внедряя структуру данных, которая помогает поддерживать порядок и облегчает поиск информации; в основном, индексирование ускоряет процесс поиска данных и делает его более эффективным, тем самым экономя время (и систему) и усилия.
## Приобрести более мощный процессор
Чем лучше процессор, тем быстрее и эффективнее будет база данных. Поэтому, если база данных работает не так, нужо рассмотреть возможность обновления процессорного модуля более высокого класса; чем мощнее процессор, тем меньше нагрузка при работе с несколькими приложениями и запросами. Кроме того, при оценке производительности ЦП важно отслеживать все аспекты производительности ЦП, в том числе время готовности ЦП (которое может рассказать о случаях, когда система пыталась использовать ЦП, но не смогла, поскольку все ресурсы ЦП были слишком заняты).
## Выделить больше памяти
Повлиять на эффективность базы данных может нехватка памяти. Когда в базе данных недостаточно памяти для выполнения запрашиваемой работы, производительность базы данных по понятным причинам пойдет на спад. Наличие большего объема памяти поможет повысить эффективность системы и общую производительность. Хороший способ проверить, нужно ли больше памяти — посмотреть, сколько ошибок в системе имеет страница. Если количество сбоев велико (например, в тысячах), это означает, что хостам не хватает доступного пространства памяти.  
Кроме того, можно рассмотреть вопрос об увеличении объема памяти, ис-пользуемой MySQL. Рекомендуется разрешить ему выделять 70% общей памяти (при условии, что база данных является единственным приложением на этом сервере). Можно изменить объем памяти, выделенной для базы данных, используя ключ innodb_buffer_pool_size в файле конфигурации MySQL, my.cnf.
## Дефрагментация данных
Если имеются проблемы с медленной базой данных, другим возможным решением является дефрагментация данных. Когда в базу данных записывается много записей и время идет, записи фрагментируются во внутренних файлах данных MySQL и на самом диске. Дефрагментация диска позволит сгруппировать соответствующие данные, поэтому операции, связанные с вводом/выводом, будут выполняться быстрее, что напрямую повлияет на общую производительность запросов и базы данных. Кроме того, на некотором связанном примечании также важно иметь достаточно дискового пространства вообще, работая с базой данных. Если нужно оптимизировать производительность базы данных, необходимо использовать дефрагментацию диска, сохраняя при этом достаточно свободного дискового пространства для базы данных.
## Типы дисков
Для извлечения результатов даже одного запроса могут потребоваться миллионы операций ввода-вывода с диска, в зависимости от объема данных, к которым запрос должен получить доступ для обработки, и в зависимости от объема данных, возвращаемых из запроса. Таким образом, тип дисков на сервере может сильно повлиять на производительность SQL запросов. Работа с SSD-дисками может значительно повысить общую производительность базы данных и, в частности, производительность SQL-запросов.
## Версия базы данных
Другим важным фактором производительности базы данных является версия MySQL, которую в настоящее время развертывают. Обновление последней версии базы данных может существенно повлиять на общую производительность базы данных. Возможно, что один запрос может работать лучше в старых версиях MySQL, чем в новых, но если посмотреть на общую производительность, новые версии, как правило, работают лучше.
