

## Уровни архитектуры веб-приложений
Существует четыре общих уровня веб-приложений:  
  
-   Уровень представления (PL)   
-   Уровень обслуживания данных (DSL)  
-   Уровень бизнес-логики (BLL)  
-   Уровень доступа к данным (DAL)

**Уровень представления**  
PL отображает пользовательский интерфейс и упрощает взаимодействие с пользователем. Уровень представления имеет компоненты пользовательского интерфейса, которые визуализируют и показывают данные для пользователей. Также существуют компоненты пользовательского процесса, которые задают взаимодействие с пользователем. PL предоставляет всю необходимую информацию клиентской стороне. Основная цель уровня представления - получить входные данные, обработать запросы пользователей, отправить их в службу данных и показать результаты.  
  
**Слой бизнес-логики**  
BLL несет ответственность за надлежащий обмен данными. Этот уровень определяет логику бизнес-операций и правил. Вход на сайт - это пример уровня бизнес-логики.  
  
**Уровень службы данных**  
DSL передает данные, обработанные уровнем бизнес-логики, на уровень представления. Этот уровень гарантирует безопасность данных, изолируя бизнес-логику со стороны клиента.  
  
**Уровень доступа к данным**  
DAL предлагает упрощенный доступ к данным, хранящимся в постоянных хранилищах, таких как двоичные файлы и файлы XML. Уровень доступа к данным также управляет операциями CRUD - создание, чтение, обновление, удаление.

## Монолитная и микросервисная архитектура
 
**Монолитная архитектура** — это традиционная модель программного обеспечения, которая представляет собой единый модуль, работающий автономно и независимо от других приложений. Она состоит из трех частей - базы данных, клиентской и серверной сторон. Это означает, что внутренняя и внешняя логика, как и другие фоновые задачи, генерируются в одной кодовой базе. Чтобы изменить или обновить компонент приложения, разработчики программного обеспечения должны переписать все приложение.  
  **Микросервисная архитектура** — один из подходов проектирования, при котором единое приложение строится как набор небольших сервисов. Каждый модуль работает в собственном процессе и взаимодействует с другими модулями. Модули работают независимо и построены вокруг бизнес-потребностей и выполняют определённую функцию. Этот подход позволяет разработчикам создавать веб-приложение из набора небольших сервисов. Разработчики создают и развертывают каждый компонент отдельно.  Каждый сервис может быть изменен без ущерба для других блоков. 
  
  ## Почему не все приложения построены на микросервисной архитектуре?
  При кажущейся простоте и логичности деление большого монолитного приложения на самостоятельные сервисы — сложная техническая задача. Сам микросервисный подход не лишён недостатков, поэтому не всегда заменяют монолитную архитектуру микросервисами:

-   **Сложнее осуществлять мониторинг**. Монолит один, и отслеживать, как он работает проще. Микросервисов сотни, а иногда тысячи, и уследить за каждым физически невозможно. Поэтому приходится уделять много внимания системам управления и мониторинга.
    
-   **Каждый микросервис может использовать тот язык программирования и те технологии, что удобны команде, которая его разрабатывает**. С одной стороны, это плюс — какие-то фреймворки и языки лучше заточены под конкретные вещи. Если мы делаем сервис обработки изображений или машинного обучения, можем не заострять внимание на технологиях монолита, а выбрать решение под задачу. С другой стороны, это минус — нужно как-то конфигурировать все микросервисы между собой и поддерживать «зоопарк» технологий.
    
-   **Снижение доверия**. Когда у нас сотни узлов, могут возникать проблемы с аутентификацией и авторизацией, поскольку есть вероятность подсоединения мошенников.
    
-   **Сложности развёртывания**. Чтобы требования по отказоустойчивости выполнялись, микросервисы нужно развёртывать на отдельных серверах. И здесь не работает подход: «Берём приложение, ставим и запускаем». Нужны системы оркестрации и деплоймента.

Чаще всего монолитную архитектуру используют если приложение небольшое. При масштабировании есть возможность перейти на микросервисную архитектуру. Либо сразу использовать микросервисную архитектуру, если изначально известно, что приложение будет большим.

 Каковы особенности тестирования монолитных и микросервисных веб-приложений?
## Тестирования монолитных веб-приложений
 **Плюсы**:
- Удобное тестирование. Протестировать монолитное приложение гораздо проще, чем микросервисы. Можно запустить и протестировать приложение на сервере разработчика или в промежуточной среде, а также применить стандартный процесс развертывания для проверки изменений перед запуском приложения в продакшн.
- Снижение затрат на поддержку. При монолите нужно поддерживать только один репозиторий. Понадобится только один конвейер тестирования и развертывания, что может значительно снизить затраты, поскольку создание, настройка и обслуживание нескольких конвейеров выйдет дороже, ведь нужно будет обеспечить согласованность между ними. Все данные, используемые приложением, также могут храниться в единой базе данных.

**Минусы**:
- Высокий уровень зависимостей. Единый код означает, что компоненты тесно связаны, и изменения в логике одного модуля или службы сопряжены с гораздо более высоким риском влияния на код и работу других модулей. Порой трудно предсказать последствия для приложения даже после небольших изменений в коде. Поэтому каждое обновление вынуждает повторно тестировать весь продукт.

## Тестирования микросервисных веб-приложений
**Плюсы**:
- Легкость тестирования. В отдельных службах легко находить и исправлять ошибки и баги.
- Уменьшение времени на тестирование.
- Скорость тестирования. Изменения в одном виджете или странице можно протестировать изолированно и только в этом приложении, не тратя времени на тестирование всего остального функционала.

**Минусы**:
- Более затруднительное взаимодействие при тестировании (тесты E2E)
- Потребность в более квалифицированных тестировщиках. В соответствии с потребностями бизнеса команда тестировщиков разбивается по сервисам. Поэтому тестировщик должен уметь выполнять кросс-функциональное тестирование интерфейса пользователя UX, баз данных и программного интерфейса API. Для тестирования межсервисного взаимодействия нужно разбираться в структуре всей программы, знать бизнес-задачи, т.е. быть готовым заниматься менеджментом проекта. Проблем для тестировщика при таком подходе к проектированию программ прибавляется, повышается его экспертность, по сравнению с тестированием монолитного приложения, когда можно не вникать в процесс а повторно тестировать одно и то же много раз, при внесении небольших изменений в разрабатываемый проект.
- Сложность тестирования. С одной стороны, тестировать отдельные микросервисы проще, с другой, необходимость тестировать каждый сервис по отдельности может значительно усложнить приложение по мере его масштабирования. А необходимость тестировать и поддерживать связь между службами создает дополнительную сложность.
- Более высокие первоначальные затраты. Придется наладить процесс автоматического тестирования и развертывания (CI/CD).
- Тестирование MOA должно происходить как на микроуровне, так и на макроуровне. Обычного модульного тестирования недостаточно. На микроуровне каждый сервис должен быть досконально протестирован в пределах своей зоны ответственности. При тестировании микросервисов на макроуровне необходимо убедиться, что два аспекта не вызывают нареканий: межсервисная коммуникация и процессы развертывания.
