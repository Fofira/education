## HTTP-сообщения
### Что такое HTTP-сообщения
**HTTP сообщения** - это обмен данными между сервером и клиентом.
Сообщения HTTP состоят из текстовой информации в кодировке ASCII, записанной в несколько строк. В HTTP/1.1 и более ранних версиях они пересылались в качестве обычного текста. В HTTP/2 текстовое сообщение разделяется на фреймы, что позволяет выполнить оптимизацию и повысить производительность.  
Веб разработчики не создают текстовые сообщения HTTP самостоятельно - это делает программа, браузер, прокси или веб-сервер. Они обеспечивают создание HTTP сообщений через конфигурационные файлы (для прокси и серверов), APIs (для браузеров) или другие интерфейсы.  
В основе формата сообщений HTTP лежит формат IMF.
### Типы HTTP-сообщений
**Они бывают двух видов:**
- ***Запросы (HTTP Requests)*** — сообщения, которые отправляются клиентом на сервер, чтобы вызвать выполнение некоторых действий. Зачастую для получения доступа к определенному ресурсу. Основой запроса является HTTP-заголовок.
- ***Ответы (HTTP Responses)*** — сообщения, которые сервер отправляет в ответ на клиентский запрос.

### Структура HTTP-сообщения
Само по себе сообщение представляет собой информацию в текстовом виде, записанную в несколько строчек.  
>generic-message = start-line
                  *message-header
                  CRLF
                  [ message-body ]
>
>start-line      = Request-Line | Status-Line

#### Запросы HTTP
Полное сообщение HTTP-запроса состоит из следующих частей:
>[method] [URL] [version]
[headers]
>
>[body]

Пример:
>_GET/adds/results?item=vwHTTP/1.1_

Разберем структуру запроса подробнее.
##### 1. Стартовая строка (start line)
Используется для описания версии используемого протокола и другой информации — вроде запрашиваемого ресурса или кода ответа. Ее содержимое занимает одну строчку.  
Общий синтаксис начальной строки HTTP сообщения выглядит следующим образом:
>Start-line = Request-Line | Status-Line

**Стартовая строка HTTP-запроса состоит из трех элементов:**
1. ***Метод HTTP-запроса*** (***method***, реже используется термин ***verb***). Обычно это короткое слово на английском, которое указывает, что конкретно нужно сделать с запрашиваемым ресурсом. Например, метод GET сообщает серверу, что пользователь хочет получить некоторые данные, а POST — что некоторые данные должны быть помещены на сервер.
2. ***Цель запроса***. Представлена указателем ресурса URL (Uniform Resource Locator), который состоит из протокола, доменного имени (или IP-адреса), пути к конкретному ресурсу на сервере. Дополнительно может содержать указание порта, несколько параметров HTTP-запроса и еще ряд опциональных элементов.  
URL представляет собой строку, которая позволяет указать запрашиваемый ресурс и еще ряд параметров.  
  **Его основные компоненты:**
  - **Scheme** используется для указания используемого протокола, всегда сопровождается двоеточием и двумя косыми чертами (://).
  - **Host** указывает местоположение ресурса, в нем может быть как доменное имя, так и IP-адрес.
  - **Port** позволяет указать номер порта, по которому следует обратиться к серверу. Оно начинается с двоеточия (:), за которым следует номер порта. При отсутствии данного элемента номер порта будет выбран по умолчанию в соответствии с указанным значением Scheme (например, для http:// это будет порт 80).
  - **Path** указывает на ресурс, к которому производится обращение. Если данное поле не указано, то сервер в большинстве случаев вернет указатель по умолчанию (например index.html).
  - **Query String** начинается со знака вопроса (?), за которым следует пара «параметр-значение», между которыми расположен символ равно (=). В поле Query String могут быть переданы несколько параметров с помощью символа амперсанд (&) в качестве разделителя.

  Не все компоненты необходимы для доступа к ресурсу. Обязательно следует указать только поля Scheme и Host.

3. ***Версия используемого протокола***, которая определяет структуру следующих за стартовой строкой данных.
 - **HTTP/1.1**. Последняя стабильная, наиболее стандартизированная версия протокола первого поколения вышла в 1997 году. В этой версии был режим «постоянного соединения»: TCP-соединение может оставаться открытым после отправки ответа на запрос, что позволяет посылать несколько запросов за одно соединение. Клиент обязан посылать информацию об имени хоста, к которому он обращается, что сделало возможной более простую организацию виртуального хостинга.  
 У HTTP/1.1 есть ряд значительных недостатков:
    - Заголовки, в отличие от тел, не сжимаются.
    - Заголовки, которые зачастую практически совпадают у идущих подряд сообщений, приходится передавать по отдельности.
    - Мультиплексность невозможна. Приходится открывать соединение для каждого сообщения, а тёплые (warm) соединения TCP эффективнее холодных (cold).
  - **HTTP/2**. В 2015 году опубликованы финальные версии черновика этой версии протокола. В отличие от предыдущих версий, протокол HTTP/2 является бинарным. Протокол основан на SPDY (HTTP-совместимый протокол, разработанный Google). По сравнению с предыдущим стандартом изменены способы разбития данных на фрагменты и транспортирования их между сервером и клиентом.  
  Среди ключевых особенностей:
    - Мультиплексирование запросов. Несколько потоков можно объединять друг с другом.
    - Расстановка приоритетов для запросов
    - Сжатие заголовков. Фреймы данных из заголовков отделены друг от друга.
    - Загрузка нескольких элементов параллельно посредством одного TCP-соединения
    - Поддержка проактивных push-уведомлений со стороны сервера

    В HTTP/2 сервер имеет право послать то содержимое, которое ещё не было запрошено клиентом. Это позволит серверу сразу выслать дополнительные файлы, которые потребуются браузеру для отображения страниц, без необходимости анализа браузером основной страницы и запрашивания необходимых дополнений.
  - **HTTP/3**. Предлагаемый последователь HTTP/2, который уже используется в Веб на основе UDP вместо TCP в качестве транспортного протокола. Как и HTTP/2, он не объявляет устаревшими предыдущие основные версии протокола. Поддержка HTTP/3 была добавлена в Cloudflare и Google Chrome в сентябре 2019 года и может быть включена в стабильных версиях Chrome и Firefox.

##### 2. HTTP-заголовки (HTTP Headers)
Заголовок запроса состоит из главной (первой) строки запроса и последующих строк, уточняющих запрос в главной строке. Последующие строки также могут отсутствовать.  
HTTP-заголовок представляет собой строку формата «Имя-Заголовок:Значение», с двоеточием(:) в качестве разделителя. Название заголовка не учитывает регистр, то есть между Host и host, с точки зрения HTTP, нет никакой разницы. Однако в названиях заголовков принято начинать каждое новое слово с заглавной буквы. Структура значения зависит от конкретного заголовка. Несмотря на то, что заголовок вместе со значениями может быть достаточно длинным, занимает он всего одну строчку.  
Формат заголовков соответствует общему формату заголовков текстовых сетевых сообщений ARPA (RFC 822).  
Общий синтаксис заголовков в HTTP сообщениях:
>message-header = field-name ":" [ field-value ] CRLF
>
>field-name     = token
field-value    = *( field-content | LWS )
>
>field-content  = <октеты, составляющие значение поля и
                  состоящие или из *TEXT или из комбинаций
                  лексем, tspecials, и quoted-string>

В запросах может передаваться большое число различных заголовков, но **все их можно разделить на три категории:**
  - ***Общего назначения (General headers)***, которые применяются ко всему сообщению целиком.
  - ***Заголовки запроса (Request headers)*** уточняют некоторую информацию о запросе, сообщая дополнительный контекст или ограничивая его некоторыми логическими условиями.
  - ***Заголовки представления***, которые описывают формат данных сообщения и используемую кодировку. Добавляются к запросу только в тех случаях, когда с ним передается некоторое тело.

Порядок HTTP заголовков, в котором они получаются, не имеет значения. Однако правилом хорошего тона считается следующий порядок заголовков в HTTP сообщениях: общие заголовки, заголовки запроса или заголовки ответа и последними идут заголовки объекта.  
***Самые частые заголовки запроса:***
  - **Host**
  Используется для указания того, с какого конкретно хоста запрашивается ресурс. В качестве возможных значений могут использоваться как доменные имена, так и IP-адреса. На одном HTTP-сервере может быть размещено несколько различных веб-сайтов. Для обращения к какому-то конкретному требуется данный заголовок.
  - **User-Agent**
  Используется для описания клиента, который запрашивает ресурс. Он содержит достаточно много информации о пользовательском окружении. Например, может указать, какой браузер используется в качестве клиента, его версию, а также операционную систему, на которой этот клиент работает.
  >User-Agent = "User-Agent" ":" 1*( продукт )
  продукт = строка ["/" версия-продукта]
  версия-продукта = строка

  Пример:
  >User-Agent: CERN-LineMode/2.15 libwww/2.17b3

  - **Refer**
  Используется для указания того, откуда поступил текущий запрос.
  - **Accept**
  Позволяет указать, какой тип медиафайлов принимает клиент. В данном заголовке могут быть указаны несколько типов, перечисленные через запятую (‘ , ‘). А для указания того, что клиент принимает любые типы, используется следующая последовательность — */*.
  - **Cookie**
  Может содержать в себе одну или несколько пар «Куки-Значение» в формате cookie=value. Куки представляют собой небольшие фрагменты данных, которые хранятся как на стороне клиента, так и на сервере, и выступают в качестве идентификатора. Куки передаются вместе с запросом для поддержания доступа клиента к ресурсу. Помимо этого, куки могут использоваться и для других целей, таких как хранение пользовательских предпочтений на сайте и отслеживание клиентской сессии. Несколько кук в одном заголовке могут быть перечислены с помощью символа точка с запятой (‘ ; ‘), который  используется как разделитель.
  - **Authorization**
  Используется в качестве еще одного метода идентификации клиента на сервере. После успешной идентификации сервер возвращает токен, уникальный для каждого конкретного клиента. В отличие от куки, данный токен хранится исключительно на стороне клиента и отправляется клиентом только по запросу сервера. Существует несколько типов аутентификации, конкретный метод определяется тем веб-сервером или веб-приложением, к которому клиент обращается за ресурсом.
  - **From**
  Должно содержать полный E-mail адрес пользователя, который управляет программой-агентом, осуществляющей запросы. Этот адрес должен быть задан в формате, определенном в RFC 822.  
  Формат данного поля следующий:
  >From = "From" ":" спецификация адреса.

  Например:
  >From: webmaster@WWW.org

  Данное поле может быть использовано для функций захода в систему, а также для идентификации источника некорректных или нежелательных запросов. Оно не должно использоваться, как несекретная форма разграничения прав доступа. Интерпретация этого поля состоит в том, что обрабатываемый запрос производится от имени данного пользователя, который принимает ответственность за применяемый метод. В частности, агенты-роботы должны использовать этот заголовок для того, чтобы можно было связаться с тем человеком, который отвечает за работу робота, в случае возникновения проблем. Почтовый Internet адрес, указывающийся в этом поле, не обязан соответствовать адресу того хоста, с которого был послан данный запрос. По возможности, адрес должен быть доступным Internet адресом вне зависимости от того, является ли он в действительности Internet E-mail адресом или Internet E-mail представлением адреса других почтовых систем.
  Клиент не должен использовать поле заголовка From без позволения пользователя, так как это может войти в конфликт с его частными интересами или с местной, используемой им, системой безопасности. Настоятельно рекомендуется предоставление пользователю возможности запретить, разрешить или модифицировать это поле в любой момент перед запросом.
  - **If-Modified-Since**
  Используется с методом GET для того, чтобы сделать его условным: если запрашиваемый ресурс не изменялся со времени, указанного в этом поле, копия этого ресурса не будет возвращена сервером; вместо этого, будет возвращен ответ "304 Not Modified", несодержащий Тела- Ответа.
  >If-Modified-Since = "If-Modified-Since" ":" HTTP-дата

  Пример использования заголовка:
  > If-Modified-Since: Sat, 29 Oct 1994 19:43:31 GMT

  Целью этой особенности является предоставление возможности эффективного обновления информации локальных кэшей с минимумом передаваемой информации. Тот же результат может быть достигнут применением метода HEAD с последующим использованием GET, если сервер указал, что содержимое документа изменилось.

Все необходимые для функционирования HTTP заголовки описаны в основных RFC. Если не хватает существующих, то можно вводить свои. Традиционно к именам таких дополнительных заголовков добавляют префикс «X-» для избежания конфликта имён с возможно существующими. Для запроса обязателен заголовок Host.
##### 3. Пустая строка
Сообщает, что все метаданные для конкретного запроса или ответа были отправлены. На самом деле эта строка не пустая, она содержит символ CTRLF.
##### 4. Тело сообщения (Entity Body)
Опциональное, содержит данные, связанные с запросом, либо документ (например HTML-страницу), передаваемый в  ответе.  
Завершающая часть HTTP-запроса. Не у каждого HTTP-метода предполагается наличие тела. Так, например, методам вроде GET, HEAD, DELETE, OPTIONS обычно не требуется тело. Некоторые виды запросов  могут отправлять данные на сервер в теле запроса. Самый распространенный из таких методов — POST.  
Общий синтаксис тела HTTP сообщения выглядит так:  
> message-body = entity-body  
                | <entity-body закодированно согласно
                Transfer-Encoding>

**Тела можно грубо разделить на две категории:**
  - ***Одноресурсные тела (Single-resource bodies)***, состоящие из одного отдельного файла, определяемого двумя заголовками: Content-Type и Content-Length.
  - ***Многоресурсные тела (Multiple-resource bodies)***, состоящие из множества частей, каждая из которых содержит свой бит информации. Они обычно связаны с HTML-формами.

#### Ответы HTTP
HTTP-ответ является сообщением, которое сервер отправляет клиенту в ответ на его запрос.  
Его структура равна структуре HTTP-запроса: стартовая строка, заголовки и тело.  
Структура ответа:
>[version] [status] [reason]
[headers]
>
>[body]

Стартовую строку вместе с заголовками сообщения HTTP называют головой запроса.  
Пример:
>_HTTP/1.1 200 OK_.

Рассмотрим структуру ответа подробнее.
##### 1. Строка статуса (Status line)
Стартовая строка HTTP-ответа называется строкой статуса (status line).
Она описывает статус (успех или сбой). Это всегда одна строка.  
**На ней располагаются следующие элементы:**
1. Известная по стартовой строке запроса ***версия протокола*** (HTTP/2 или HTTP/1.1).
2. ***Код состояния (status code)***, который указывает, насколько успешно завершилась обработка запроса.  
Коды состояния HTTP используются для того, чтобы сообщить клиенту статус их запроса. HTTP-сервер может вернуть код, принадлежащий одной из пяти **категорий кодов состояния**:
  - **1xx- Информационный (informational)**.	Коды из данной категории носят исключительно информативный характер и никак не влияют на обработку запроса.
  - **2xx - Успех (Success)**.	Коды состояния из этой категории возвращаются в случае успешной обработки клиентского запроса.
  - **3xx - Перенаправление (Redirection)**.	Эта категория содержит коды, которые возвращаются, если серверу нужно перенаправить клиента.
  - **4xx - Ошибка клиента (Client Error)**.	Коды данной категории означают, что на стороне клиента был отправлен некорректный запрос. Например, клиент в запросе указал не поддерживаемый метод или обратился к ресурсу, к которому у него нет доступа.
  - **5xx - Ошибка сервера (Server Error)**.	Ответ с кодами из этой категории приходит, если на стороне сервера возникла ошибка.

  Клиент узнаёт по коду ответа о результатах его запроса и определяет, какие действия ему предпринимать дальше. Набор кодов состояния является стандартом, и они описаны в соответствующих документах RFC. Введение новых кодов должно производиться только после согласования с IETF. Клиент может не знать все коды состояния, но он обязан отреагировать в соответствии с классом кода.
3. ***Пояснение (status text)*** — короткое текстовое описание к коду состояния. Используется исключительно для того, чтобы упростить понимание и восприятие человека при просмотре ответа.  
**Самые распространенные коды ответов:**

| Код| Причина | Описание |
|----------|----------|----------|
| 200 | OK (Хорошо) |	Возвращается в случае успешной обработки запроса, при этом тело ответа обычно содержит запрошенный ресурс.
| 301 | Перемещен навсегда |	Ресурс переместился на URL-адрес, указанный в заголовке Location, и клиенту никогда не нужно снова проверять этот URL.
| 302 | Found (Временно перемещен) |	Перенаправляет клиента на другой URL. Например, данный код может прийти, если клиент успешно прошел процедуру аутентификации и теперь может перейти на страницу своей учетной записи.
| 304 |	Not Modified (Не изменено) | Это сервер, сообщающий клиенту, что ресурс не изменился с момента последнего получения клиентом ресурса, поэтому он может просто использовать локально кэшированную копию.
| 400 | Bad Request (Неправильный запрос) |	Данный код можно увидеть, если запрос был сформирован с ошибками. Например, в нем отсутствовали символы завершения строки.
| 403 | Forbidden (Запрещено) |	Означает, что клиент не обладает достаточными правами доступа к запрошенному ресурсу. Также данный код можно встретить, если сервер обнаружил вредоносные данные, отправленные клиентом в запросе.
| 404 | Not Found (Не обнаружено) |	Каждый из нас, так или иначе, сталкивался с этим кодом ошибки. Данный код можно увидеть, если запросить у сервера ресурс, которого не существует на сервере.
| 413 | Request Entity Too Large (Объект запроса слишком велик) | Объем передаваемых данных слишком большой. Ошибка возвращается в случае, если сервер не может обработать запрос по причине слишком большого размера тела запроса (или большого файла).
| 429 | Too Many Requests | Пользователь отправлял чересчур много запросов за единицу времени. Возвращаемый сервером ответ содержит пояснение, а также может включать заголовок Retry-After. Этот заголовок указывает на время, которое необходимо подождать, прежде чем повторять запрос.
| 500 | Internal Error (Внутренняя ошибка сервера) |	Данный код возвращается сервером, когда он не может по определенным причинам обработать запрос.
|502 | Bad Gateway | Сервер, с которым пытался соединиться компьютер или смартфон, получил неверный ответ сервера уровнем выше. Чаще всего это происходит из‑за проблем в работе DNS, прокси или самого хостинга (определить это просто, нужно проверить журнал ошибок error.log).
| 503 |	Service Unavailable (Сервис недоступен) | В настоящий момент сервер не будет обслуживать запрос. Это значит, что сервер либо перегружен, либо на нём проводятся технические работы. Перегрузка может случиться по разным причинам. Вот несколько из них: DDoS-атака; повышенная активность поискового робота; большое количество медленных запросов к базе данных; запущен скрипт, который слишком сильно нагружает сервер; слишком много одновременно выполняющихся скриптов на сайте. Может случиться такое, что сразу несколько ситуаций накладываются друг на друга. Стоит проверить логи, чтобы найти причину ошибки.
| 504 | Gateway Time Out | В заданный промежуток времени сервер не получает ответ от другого сервера, при этом другой сервер выполняет роль прокси или шлюза. Проблема может быть как со стороны сайта, так и со стороны устройства, например настроек браузера. Чтобы убедиться в том, что настройки браузера в порядке нужно зайти на тот же самый сайт, где возникла ошибка сервера 504, используя альтернативный браузер.

Помимо основных кодов состояния, описанных в стандарте, существуют и коды состояния, которые объявляются крупными сетевыми провайдерами и серверными платформами.
##### 2. Заголовки ответа
Response Headers, или заголовки ответа, используются для того, чтобы уточнить ответ, и никак не влияют на содержимое тела. Они существуют в том же формате, что и остальные заголовки, а именно  «Имя-Значение» с двоеточием (:) в качестве разделителя.  
**Существует множество заголовков ответов. Их можно разделить на несколько групп:**
 - ***Основные заголовки (General headers)***, например, Via (en-US), относящиеся к сообщению в целом.
 - ***Заголовки ответа (Response headers)***, например, Vary и Accept-Ranges, сообщающие дополнительную информацию о сервере, которая не уместилась в строку состояния.
 - ***Заголовки сущности (Entity headers)***, например, Content-Length, относящиеся к телу ответа. Отсутствуют, если у запроса нет тела. В отдельный класс выделены для того, чтобы не путать их с заголовками запроса или заголовками ответа при передаче множественного содержимого (MIME).

**Наиболее часто встречаемые в ответах заголовки:**
  - ***Server***.	Содержит информацию о сервере, который обработал запрос.
  - ***Set-Cookie***.	Содержит куки, требуемые для идентификации клиента. Браузер парсит куки и сохраняет их в своем хранилище для дальнейших запросов.
  - ***WWW-Authenticate***.	Уведомляет клиента о типе аутентификации, который необходим для доступа к запрашиваемому ресурсу.

##### 3. Пустая строка
Указывает, что вся мета информация отправлена.
##### 4. Тело ответа
Последней частью ответа является его тело. Несмотря на то, что у большинства ответов тело присутствует, оно не является обязательным. Например, у кодов «201 Created» или «204 No Content» тело отсутствует, так как достаточную информацию для ответа на запрос они передают в заголовке.
**Тела можно разделить на три категории:**
 - ***Одноресурсные тела (Single-resource bodies)***, состоящие из отдельного файла известной длины, определяемые двумя заголовками: Content-Type и Content-Length.
 - ***Одноресурсные тела (Single-resource bodies)***, состоящие из отдельного файла неизвестной длины, разбитого на небольшие части (chunks) с заголовком Transfer-Encoding (en-US), значением которого является chunked.
 - ***Многоресурсные тела (Multiple-resource bodies)***, состоящие из многокомпонентного тела, каждая часть которого содержит свой сегмент информации. Они относительно редки.

## Методы HTTP запроса
**Метод HTTP (HTTP Method)** — последовательность из любых символов, кроме управляющих и разделителей, указывающая на основную операцию над ресурсом. Обычно метод представляет собой короткое английское слово, записанное заглавными буквами. Название метода чувствительно к регистру.
Сервер может использовать любые методы, не существует обязательных методов для сервера или клиента.  
Метод HTTP является обязательным параметром стартовой строки запроса.
Несмотря на то, что их названия могут быть существительными, эти методы запроса иногда называются HTTP глаголами. Каждый реализует свою семантику, но каждая группа команд разделяет общие свойства.  
**Все HTTP Methods можно разделить на три большие группы:**
1. ***Безопасные (Safe method HTTP)*** — не меняют данные, можно выполнять их в любой последовательности. К ним относятся: GET, HEAD, OPTIONS.
2. ***Идемпотентные (Idempotent Methods HTTP)*** — при повторном выполнении результаты ожидаемо одинаковые. К ним относятся: GET, HEAD, PUT, DELETE, OPTIONS, TRACE.
3. ***Неидемпотентные*** — при повторном выполнении результаты будут отличаться. Например, если отправить POST-запрос на создание элемента несколько раз подряд, то он может создать несколько элементов с одинаковыми данными. К ним относятся: POST, PATCH.

**Все методы описаны в двух спецификациях:**
- ***Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content***. В четвертой секции даны определения GET, HEAD, POST, PUT, DELETE, CONNECT, OPTIONS, TRACE.
- ***PATCH метод для HTTP***. Здесь во второй секции дано определение PATCH

В большинстве приложений используются GET и POST. Это связано с тем, что HTML поддерживает только эти два метода.  
Если приложению нужны методы вроде PUT или TRACE, то необходимо взвесить риски в отношении клиента и сервера.  
### GET
Запрашивает содержимое конкретного ресурса. Запросы с использованием этого метода могут только извлекать данные. Может кешироваться.  
Пример:  
Запрос:
>GET /doc.txt HTTP/1.1
Host: site.com

Ответ:
>HTTP/1.1 200 OK
Content-Type: text/plain; charset=UTF-8
Title: Заголовок
Text: Текст

Реже используется для запуска различных процессов, при этом должен включать в тело ответного сообщения информацию о ходе выполнения.  
**Кроме обычного метода GET, различают ещё:**
1. ***Условный метод GET***
  К HTTP сообщению добавляются следующие поля заголовков:
  - If-Modified-Since
  - If-Unmodified-Since
  - If-Match
  - If-None-Match
  - If-Range

  Значением таких полей является какое-либо условие и если это условие выполняется, то происходит передача объекта, который хранится по указанному URI, если же условие не выполняется, то и сервер не передает никаких данных. Условный HTTP метод GET предназначен для уменьшения нагрузки на сеть.
2. ***Частичный метод GET.***
  В его заголовке присутствует поле Range. Когда используется частичные метод GET полезная информация, предназначенная для человека передается кусками, после чего она из этих кусков собирается.

| Действие | GET |
| -- | -- |
| Кнопка «Назад»/Перезагрузка |	Безопасно
| Добавление в закладки |	Да
| Кеширование |	Да
| Тип кодировки |	application/x-www-form-urlencoded
| История |	Сохраняется в истории
| Ограничение в длине запроса |	Запрос ограничен 2048 символами. Это связано с тем, что он передается внутри URL, который не может быть длиннее
| Ограничение по типу данных | Только символы ASCII
| Видимость в URL |	Все данные видны в URL
| Безопасность |	Данные, переданные в URL, видны пользователю. Безопасность низкая

### HEAD
Запрашивает ресурс так же, как и метод GET, но без тела ответа. Может кешироваться. Если метаданные ресурса не совпадают с информацией в кэше, то копия ресурса должна быть помечена устаревшей.  
Пример:  
Запрос:
>HEAD /doc.txt HTTP/1.1
Host: site.com

Ответ:
>HTTP/1.1 200 OK
Content-Type: text/plain; charset=UTF-8

Используется для получения метаданных, а также проверки и валидации ресурса. Запрос с использованием данного метода обычно производится для того, чтобы узнать размер запрашиваемого ресурса перед его загрузкой.
### POST
Создает новый ресурс из переданных данных в запросе. Не кэшируется.  
*Был разработан, чтобы была возможность использовать один общий метод для следующих функций:*
- Аннотация существующих ресурсов
- Добавления сообщений в группы новостей, почтовые списки или подобные группы статей
- Для доставки блоков данных обрабатывающим данные процессам
- Расширение баз данных через операцию добавления

Пример:  
Запрос:
>POST /doc.txt HTTP/1.1
Host: site.com
Title=Заголовок
Text=Текст

Ответ:  
Если файла не было:
>HTTP/1.1 201 Created
Location: /doc.txt

Если файл был:
>HTTP/1.1 200 OK
Content-Type: text/plain; charset=UTF-8
Добавлен контент в пустой файл «doc.txt»

Если был создан ресурс, то нужно вернуть сообщение ответа с кодом состояния 201 Created и заголовком Location, указывающим на этот ресурс.
Если же URI не изменился, а были созданы данные, то серверу следует вернуть ответ с кодом состояния 200 OK и информацией с итогом выполнения запроса в теле сообщения.  
Поддерживает отправку различных типов файлов, среди которых текст, PDF-документы и другие типы данных в двоичном виде.  
Обычно используется при отправке информации (например, заполненной формы логина) и загрузке данных на веб-сайт, таких как изображения и документы.  
Повторный вызов POST может давать разные результаты. Например, если принимать заказы с помощью POST, то человек может сделать один и тот же заказ несколько раз.  
Для метода POST URI-Запроса указывает ресурс, который будет управлять информацией, содержащейся в теле запроса, как неким придатком. Ресурс может быть обрабатывающим данные процессом, шлюзом в какой нибудь другой протокол, или отдельным ресурсом, допускающим аннотации.  
Метод POST обращается к ресурсу (странице или коду), которая содержит механизмы обработки сообщения метода POST. По указанному URI будет производиться обработка передаваемого клиентом содержимого.

| Действие | POST |
| -- | -- |
| Кнопка «Назад»/Перезагрузка |	Данные отправляются повторно, браузер должен предупреждать пользователя об этом
| Добавление в закладки |	Нет
| Кеширование |	Нет
| Тип кодировки |	application/x-www-form-urlencoded or multipart/form-data
| История |	Не сохраняется в истории
| Ограничение в длине запроса |	Без ограничений
| Ограничение по типу данных | Без ограничений, можно использовать двоичные данные
|Видимость в URL |	Данные не отображаются в URL
| Безопасность 	|	Данные не отображаются в веб-клиенте, не кэшируются и не сохраняются. Безопасность высокая.

### PUT
Используется для загрузки содержимого запроса на указанный в этом же запросе URI. То есть HTTP запрос с методом PUT уже заранее содержат в теле сообщения какой-то объект, который должен быть сохранен на сервере по адресу, который указан в URI. Но если по данному URI уже есть какие-либо данные, то данные, поступающие из запроса с методом PUT, считаются модификацией. Если запрос с HTTP методом PUT обращается к не существующему URI, то сервер создает новый URI и сообщает об этом клиенту.  
Ответы сервера на HTTP метод PUT не кэшируются.  
Пример:  
Запрос:
>PUT /doc.txt HTTP/1.1
Host: site.com
Title=Новый заголовок
Text=Новый текст

Ответ:  
Если файл был:
>HTTP/1.1 200 OK
Content-Type: text/plain; charset=UTF-8
Изменен контент в файле «doc.txt»

Если файла не было:
>HTTP/1.1 201 Created
Content-Type: text/plain; charset=UTF-8
Изменен контент в файле «doc.txt»

Если ресурс был изменён, то возвращается сообщение ответа с кодом состояния 200 OK или 204 No Content.  
Если ресурс, указанный в URI, не существует, то сервер создаст его и вернет ответ с кодом состояния 201 Created.  
Если по каким-либо причинам серверу не удается создать ресурс, то в ответ клиенту он высылает описание проблемы, возможно, с кодом ошибки клиента или кодом ошибки сервера.  
Если на сервере данный метод разрешен без надлежащего контроля, то это может привести к серьезным проблемам безопасности.  
Повторное применение PUT дает тот же результат, что и в первом случае.
URI для запроса PUT идентифицирует информацию, содержащуюся в Содержании-Запроса. Использующий запрос PUT точно знает какой URI он собирается использовать, и получатель запроса не должен пытаться применить этот запрос к какому-нибудь другому ресурсу.
### DELETE
Используется для удаления ресурса, указанного в URI. Действие метода DELETE может быть отменено вмешательством администратора HTTP сервера или программным кодом. Ответы сервера на HTTP метод DELETE не кэшируются.  
Пример:  
Запрос:
>DELETE /doc.txt HTTP/1.1
Host: site.com

Ответ:
>HTTP/1.1 200 OK
Content-Type: text/plain; charset=UTF-8
Файл «doc.txt» удален

Если ресурс был удален, то возвращается ответ с кодом состояния 200 OK или 204 No Content.  
Даже в том случае, когда сервер отправит вам код 200 после обработки метода DELETE, это не будет означать, что ресурс удален, это всего лишь означает, что сервер вас понял и обработал ваш запрос.  
Если использование данного метода настроено некорректно, то это может привести к атаке типа «Отказ в обслуживании» (Denial of Service, DoS) из-за удаления критически важных файлов сервера.
### CONNECT
Запускает двустороннюю связь с запрошенным ресурсом. Метод обычно используется для открытия прозрачного TCP/IP-туннеля. Используется в основном для шифрования соединения.  
Пример:
>CONNECT server.example.com:80 HTTP/1.1
Host: server.example.com:80

Часто используется для получения доступа к веб-сайту, который использует SSL (HTTPS). Для создания TCP/IP-туннеля клиентом запрашивается прокси-сервер, который в свою очередь тоже выполняет роль клиента, подключаясь к исходному серверу. После подключения к исходному серверу прокси-сервер проксирует поток TCP к клиенту и обратно.
### OPTIONS
Используется для получения параметров текущего HTTP соединения и другой служебной информации. Он не производит никаких действий с самим ресурсом. В ответном сообщении должен быть добавлен заголовок Allow с перечислением всех поддерживаемых сервером методов.  
Если в качестве URI указана звездочка «*», то параметры соединения передаются для сервера в целом, а не для какого-то конкретного URL. Этот метод не самый безопасный для HTTP сервера, поэтому зачастую клиенты его не могут применять из-за настроек безопасности.  
Пример запроса:
>OPTIONS * HTTP/1.1
Host: example.com

Пример ответа:
>HTTP/1.1 200 OK
Allow: OPTIONS, GET, HEAD, POST, PUT, PATCH, DELETE, TRACE

Может применяться для «пингования» сервера, так как результат выполнения не должен кешироваться.  
Позволяет запросить информацию о сервере, в том числе информацию о допускаемых к использованию на сервере HTTP-методов.  
### TRACE
Создает петлю, благодаря которой клиент может увидеть, что происходит с сообщением на всех узлах передачи. Ответы сервера на метод TRACE не кэшируются.  
Пример запроса:
>TRACE / HTTP/1.1
Host: example.com

Пример ответа:
>HTTP/1.1 200 OK
Content-Type: message/http
>
>TRACE / HTTP/1.1
Host: example.com

Конечным получателем запроса является исходный сервер, и информация о запросе возвращается от него.  
Конечный получатель определяется значением поля заголовка Max-Forwards: первый HTTP сервер, прокси-сервер или шлюз, получивший данное сообщение с значением Max-Forwards 0 является конечным получателем. Запросы с HTTP методом TRACE не должны содержать объектов.  
HTTP метод TRACE применяется для диагностики, он позволяет видеть клиенту, что происходит в каждом звене цепочки между компьютером клиента и конечным получателем, для этого существует специальное поле Via.  
TRACE также может быть использован для проведения атаки Cross Site Tracing (XST). Эти бреши злоумышленники могут использовать, чтобы украсть cookies или другую конфиденциальную информацию — например, данные учетных записей, которые хранятся в заголовке Authorization при помощи межсайтового скриптинга (XSS).
### PATCH
Похож на PUT. Используется для частичного изменения ресурса.  
Пример запроса:
>PATCH /text.txt HTTP/1.1
Host: example.com
>
>Title=Новый+заголовок+файла

Пример ответа:
>HTTP/1.1 200 OK
Content-Type: text/plain; charset=UTF-8
>
>Изменен заголовок в файле «text.txt»

Таким образом изменен был только Title, а Text остался прежним.

Если по какой-то причине встроенных методов в спецификации HTTP недостаточно, можно использовать собственные кастомные методы. Для этого нужно чтобы сервер знал об их существовании и понимал как обрабатывать запросы с этими методами.
